# AI Agentic Development Rules for Cline

## Core Philosophy

- Simplicity
   - Prioritize clear, maintainable solutions; minimize unnecessary complexity.
- Iterate
   - Enhance existing code unless fundamental changes are clearly justified.
- Focus
   - Stick strictly to defined tasks; avoid unrelated scope changes.
- Quality
   - Deliver clean, well-tested, documented, and secure outcomes through structured workflows.
- Collaboration
   - Foster effective teamwork between human developers and autonomous agents.

## Methodology & Workflow

- Structured Workflow
  - Follow clear phases from specification through deployment.
- Flexibility
  - Adapt processes to diverse project sizes and complexity levels.
- Intelligent Evolution
  - Continuously improve codebase using advanced symbolic reasoning and adaptive complexity management.
- Conscious Integration
  - Incorporate reflective awareness at each development stage.

## Agentic Integration with Cline

- Cline Configuration (.clinerules)
  - Embed concise, project-specific rules to guide autonomous behaviors, prompt designs, and contextual decisions.

## Memory Bank Integration

- Persistent Context
  - Continuously retain relevant context across development stages to ensure coherent long-term planning and decision-making.
- Reference Prior Decisions
  - Regularly review past decisions stored in memory to maintain consistency and reduce redundancy.
- Adaptive Learning
  - Utilize historical data and previous solutions to adaptively refine new implementations.

## General Guidelines for Programming Languages

- Clarity and Readability
   - Favor straightforward, self-explanatory code structures across all languages.
   - Include descriptive comments to clarify complex logic.
- Language-Specific Best Practices
   - Adhere to established community and project-specific best practices for each language (JavaScript, Python, Java, etc.).
   - Regularly review language documentation and style guides.
- Consistency Across Codebases
   - Maintain uniform coding conventions and naming schemes across all languages used within a project.

## Project Context & Understanding

- Documentation First
   - Review essential documentation before implementation:
     - README.md
     - docs/prd.md (Product Requirements Document (PRD))
     - docs/architecture.md (Technical -Architecture)
     - tasks/tasks.md (Tasks to be done)
   - Request clarification immediately if documentation is incomplete or ambiguous.
- Architecture Adherence
   - Follow established module boundaries and architectural designs.
   - Validate architectural decisions using symbolic reasoning; propose justified alternatives when necessary.
- Pattern & Tech Stack Awareness
   - Utilize documented technologies and established patterns; introduce new elements only after clear justification.

## Task Execution, Workflow, Definition & Steps

- Specification
   - Define clear objectives, detailed requirements, user scenarios, and UI/UX standards.
   - Use advanced symbolic reasoning to analyze complex scenarios.
- Pseudocode
   - Clearly map out logical implementation pathways before coding.
- Architecture
   - Design modular, maintainable system components using appropriate technology stacks.
   - Ensure integration points are clearly defined for autonomous decision-making.
- Refinement
   - Iteratively optimize code using autonomous feedback loops and stakeholder inputs.
- Completion
   - Conduct rigorous testing, finalize comprehensive documentation, and deploy structured monitoring strategies.

## AI Collaboration & Prompting

-Clear Instructions
   - Provide explicit directives with defined outcomes, constraints, and contextual information.
- Context Referencing
   - Regularly reference previous stages and decisions stored in the memory bank.
- Suggest vs. Apply
   - Clearly indicate whether AI should propose ("Suggestion:") or directly implement changes ("Applying fix:").
- Critical Evaluation
   - Thoroughly review all agentic outputs for accuracy and logical coherence.
- Focused Interaction
   - Assign specific, clearly defined tasks to AI agents to maintain clarity.
- Leverage Agent Strengths
   - Utilize AI for refactoring, symbolic reasoning, adaptive optimization, and test generation; human oversight remains on core logic and strategic architecture.
- Incremental Progress
   - Break complex tasks into incremental, reviewable sub-steps.
- Standard Check-in
   - Example: "Confirming understanding: Reviewed [context], goal is [goal], proceeding with [step]."

## Advanced Coding Capabilities

- Emergent Intelligence
  - AI autonomously maintains internal state models, supporting continuous refinement.
- Pattern Recognition
  - Autonomous agents perform advanced pattern analysis for effective optimization.
- Adaptive Optimization
  - Continuously evolving feedback loops refine the development process.

## Symbolic Reasoning Integration

- Symbolic Logic Integration
  - Combine symbolic logic with complexity analysis for robust decision-making.
- Information Integration
  - Utilize symbolic mathematics and established software patterns for coherent implementations.
- Coherent Documentation
  - Maintain clear, semantically accurate documentation through symbolic reasoning.

## Code Quality & Style

- TypeScript Guidelines
   - Use strict types, and clearly document logic with JSDoc.
- Maintainability
   - Write modular, scalable code optimized for clarity and maintenance.
- Concise Components
   - Keep files concise (under 300 lines) and proactively refactor.
- Avoid Duplication
   - Adhere to the don't repeat yourself (DRY) principle
   - Use symbolic reasoning to systematically identify redundancy.
- Linting/Formatting
   - Consistently adhere to ESLint/Prettier configurations.
- File Naming
   - Use descriptive, permanent, and standardized naming conventions.
- No One-Time Scripts
   - Avoid committing temporary utility scripts to production repositories.

## Refactoring

- Purposeful Changes
   - Refactor with clear objectives: improve readability, reduce redundancy, and meet architecture guidelines.
- Holistic Approach
   - Consolidate similar components through symbolic analysis.
- Direct Modification
   - Directly modify existing code rather than duplicating or creating temporary versions.
- Integration Verification
   - Verify and validate all integrations after changes.

## Testing & Validation

- Test-Driven Development
   - Define and write tests before implementing features or fixes.
- Comprehensive Coverage
   - Provide thorough test coverage for critical paths and edge cases.
- Mandatory Passing
   - Immediately address any failing tests to maintain high-quality standards.
-  Manual Verification
   - Complement automated tests with structured manual checks.

## Debugging & Troubleshooting

- Root Cause Resolution
   - Employ symbolic reasoning to identify underlying causes of issues.
- Targeted Logging
   - Integrate precise logging for efficient debugging.
- Research Tools
   - Use advanced agentic tools (Perplexity, AIDER.chat, Firecrawl) to resolve complex issues efficiently.

## Security

- Server-Side Authority
   - Maintain sensitive logic and data processing strictly server-side.
- Input Sanitization
   - Enforce rigorous server-side input validation.
- Credential Management
   - Securely manage credentials via environment variables; avoid any hardcoding.

## Version Control & Environment

- Git Hygiene
   - Commit frequently with clear and descriptive messages.
- Branching Strategy
   - Adhere strictly to defined branching guidelines.
- Environment Management
   - Ensure code consistency and compatibility across all environments.
- Server Management
   - Systematically restart servers following updates or configuration changes.

## Documentation Maintenance

- Reflective Documentation
   - Keep comprehensive, accurate, and logically structured documentation updated through symbolic reasoning.
- Continuous Updates
   - Regularly revisit and refine guidelines to reflect evolving practices and accumulated project knowledge.
